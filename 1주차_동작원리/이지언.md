# 안드로이드 동작원리   
## 1) JAVA   
: 안드로이드에서 사용하는 언어는 java이지만, SUN의 java와 API와 VM이 다르다.   
  >### (1)JAVA탄생배경   
  : JAVA는 SUN마이크로 시스템즈의 제임스 고슬링이라는 사람과 연구진들이 개발한 프로그래밍 언어이다.    
  처음에는 가전제품 내에 탑재하여 동작하는 프로그램을 위해 개발했지만, 현재 웹 어플리케이션 개발에 가장 많이 사용하는 언어중 하나이다.   
  개발 당시, 유닉스 기반의 시스템이 많이 사용되었기 때문에, C/C++을 많이 사용했지만, C특성상 여러 하드웨어에 적용하기에 범용성이 떨어져서, 여러 하드웨어에 적용하기에 번거로움이 많아, java라는 언어를 개발하게 되었다.   
  
  >### (2)JAVA특징   
  : Java의 가장 큰 특징중 하나가 어떤 CPU던 간엔 OS에 상관없이 바이트 코드가 동작할 수 있다. 이를 플랫폼 독립적이라 표현한다.   
  <div>
  <img width="200" src="https://user-images.githubusercontent.com/58412156/88818109-49984800-d1f9-11ea-8a1e-384e3d455a73.png">
  </div>         
  이렇게 kernel단 위에 JVM이 올라간다. 그래서 플랫폼에 호환되는 JVM을 실행시켜줘야 한다.          
  
  >### (3)JVM           
  : JVM은 자바 애플리케이션을 클래스 로더를 통해 읽어들여 자바 API와 함께 실행하는 역할을 한다.    
    또한 어플리케이션과 OS사이에서 OS에 구애받지 않고 코드를 사용할 수 있도록 해주며, OS의 역할의 한 부분인 메모리관리와 Garbage collection을 수행한다. JVM은 스택기반의 가상머신이다. 다른 ARM아키텍쳐와 같은 하드웨어는 레지스터 기반으로 동작한다.      
    
    >cf)가상머신(VM)이라면 CPU에 의해 처리되는 동작을 흉내낼 수 있어야 한다.            
          1) 소스코드를 VM이 실행 가능한 바이트 코드로 변환한다.       
          2) 명령어와 피연산자를 포함하는 데이터 구조를 가지고 있어야 한다.        
          3) 함수를 실행하기 위한 콜 스택        
          4) IP(Instruction Pointer)로 다음 실행할 곳을 지정한다.      
          5) 가상 CPU: Fetch&Decode&Instruct         
    --가상머신을 구현하는 방법: Stack기반 vs Register기반      
          -Stack기반: 피연산자 연산 후, 결과를 스택에 저장 ->Stack: LIFO (다음 피연산자의 메모리 위치를 기억할 필요 없음)          
          -Register기반: 피연산자가 CPU내부의 Register에 저장된다. -> 명령어가 피연산자의 레지스터 주소를 기억해야 한다.명령어 길이가 길지만 다양한 연산을 할 수 있기 때문에 더 빠르다. 또한 최적화가 가능하다.         
  >### (4)Java프로그램 실행 과정            
  1. 프로그램이 실행되면 JVM은 OS로부터 필요한 메모리를 할당받는다. JVM은 할당받은 메모리를 용도에 따라 여러 영역으로 나누어 관리한다.     
  2. 자바 컴파일러 (javac)가 자바 소스코드(.java)를 읽어 자바 바이트 코드(.class)로 변환시킨다.      
  3. Class Loader를 통해 class파일을 JVM으로 로딩한다.       
  4. 로딩된 class파일들은 Execution engine을 통해 해석된다.           
  5. 해석된 바이트 코드는 Runtime Data Area에 배치되어 실질적인 수행이 이루어지게 된다.         
  --> 이 때, JVM은 필요에 따라 Thread Synchronization과 GC같은 관리작업을 수행한다.           
  <div>      
  <img width="200" src="https://user-images.githubusercontent.com/58412156/88820974-fa541680-d1fc-11ea-89c9-436eebc19907.png">         
  </div>          
      >> *class loader*       
        : JVM내로 클래스 파일을 로드하고, 링크를 통해 배치하는 작업을 수행하는 모듈. .jar파일 내 저장된 클래스 들을 JVM위에 탑재하고, 사용하지 않는 클래스들은 메모리에서 삭제한다. 자바는 런타임에 참조하기 때문에, 클래스를 처음으로 참조할 때, 해당 클래스를 로드하고 링크한다. 그 역할을 class loader가 수행한다.      
      >> *Execution Engine*       
        : 클래스를 실행시키는 역할을 하며, class loader가 JVM내의 런타임 데이터 영역에 바이트 코드를 배치시키고, 이것은 Execution Engine에 의해 실행된다. 자바 바이트 코드는 기계어보다 high language이므로, Execution엔진은 JVM내부에서 실행할 수 있는 형태로 변경한다.       
      >> *Interpreter*        
        : Execution Engine은 자바 바이트코드를 명령어 단위로 읽어서 실행한다. 하지만 이 방식은 인터프리터 언어의 특징인 한 줄 씩 수행으로 인한 느린 속도를 그대로 갖고 있다.         
      >> *JIT(Just- In - Time)*        
        : 인터프리터 방식의 단점을 보완하기 위해 JIT컴파일러가 도입된 것이다. 인터프리터 방식으로 실행하다가 적절한 시점에 바이트 코드 전체를 컴파일 하여 네이티브 코드로 변경하고, 이후에는 더이상 인터프리팅 하지 않고 네이티브 코드로 직접 실행하는 방식이다. 네이티브 코드는 캐시에 보관하기 때문에 한 번 컴파일 된 코드는 빠르게 다시 수행할 수 있다. , JIT를 사용하는 JVM은 내부적으로 해당 메서드가 얼마나 자주 수행되는지 체크하고, 일정 정도를 넘을 때에만 컴파일을 수행한다.        
      >> *Garbage collector (GC)*          
       : stop-the-world란 GC를 실행하기 위해 JVM이 애플리케이션 실행을 멈추는 것이다. GC를 실행하는 thread이외의 thread는 모두 멈추게 되고, GC작업을 완료한 후에 다시 시작한다. 어떤 GC알고리즘을 사용하더라도 stop-the-world가 발생한다. 이 시간을 줄이는 것이 GC튜닝이다.      
         Java는 프로그램 코드에서 메모리를 명시적으로 지정하여 해제하지 않는다. 종종 해당 객체를 null이나 System.gc()메서드를 호출하여 해제하기도 하는데, System.gc()메서드는 시스템 성능에 큰 영향을 끼치므로, 사용하지 않는다. 따라서 Java에서는 개발자가 메모리를 해제하지 않아서, GC가 더이상 필요없는 쓰레기 객체를 찾아 지우는 작업을 한다.         
        GC는 두가지 가설(weak generational hypothesis)에 의해 만들어지는데, 대부분의 객체는 금방 접근 불가능 상태가 된다. / 오래된 객체에서 젊은 객체로의 참조는 아주 적게 존재한다. 이 가설의 장점을 살리기 위해 HotSpot VM은 새로 할당받으면 Young Generation영역에 위치시키고, 대부분의 객체가 금방 접근 불가능 상태가 되기 때문에 금방 사라진다. 이때, Minor GC가 발생한다고 한다. 그리고 Young영역에서 살아남은 객체가 Old영역에 복사된다. 대부분 Young영역보다 크게 할당하며, 크기가 크기 때문에 GC는 적게 발생한다. 이 영역에서 객체가 사라질 때, Major GC가 발생한다고 말한다. 객체나 억류된 문자열 정보가 Permanent Generation에 저장된다. 이는 영원히 남아있는 곳은 아니다.        
         Old영역에 있는 객체가 Young 영역의 객체를 참조할 경우, Old역역에 512바이트의 카드 테이블이 존재하여, 참조할 때 마다 정보가 card table에 저장되고, Young역역에 GC를 실행할 때, Old영역의 참조 정보를 모두 확인할 필요 없이, 이 card table만 뒤져서 GC대상인지 식별한다. 카드테이블은 write barrier를 사용하여 오버헤드는 발생하지만 Minor GC를 빠르게 하도록 한다.     
