# 안드로이드 동작원리   
## 1) JAVA   
: 안드로이드에서 사용하는 언어는 java이지만, SUN의 java와 API와 VM이 다르다.   
  >### (1)JAVA탄생배경   
  : JAVA는 SUN마이크로 시스템즈의 제임스 고슬링이라는 사람과 연구진들이 개발한 프로그래밍 언어이다.    
  처음에는 가전제품 내에 탑재하여 동작하는 프로그램을 위해 개발했지만, 현재 웹 어플리케이션 개발에 가장 많이 사용하는 언어중 하나이다.   
  개발 당시, 유닉스 기반의 시스템이 많이 사용되었기 때문에, C/C++을 많이 사용했지만, C특성상 여러 하드웨어에 적용하기에 범용성이 떨어져서, 여러 하드웨어에 적용하기에 번거로움이 많아, java라는 언어를 개발하게 되었다.   
  
  >### (2)JAVA특징   
  : Java의 가장 큰 특징중 하나가 어떤 CPU던 간엔 OS에 상관없이 바이트 코드가 동작할 수 있다. 이를 플랫폼 독립적이라 표현한다.   
  <div>
  <img width="600" src="https://user-images.githubusercontent.com/58412156/88818109-49984800-d1f9-11ea-8a1e-384e3d455a73.png">
  </div>         
  이렇게 kernel단 위에 JVM이 올라간다. 그래서 플랫폼에 호환되는 JVM을 실행시켜줘야 한다.          
  
  >### (3)JVM           
  : JVM은 자바 애플리케이션을 클래스 로더를 통해 읽어들여 자바 API와 함께 실행하는 역할을 한다.    
    또한 어플리케이션과 OS사이에서 OS에 구애받지 않고 코드를 사용할 수 있도록 해주며, OS의 역할의 한 부분인 메모리관리와 Garbage collection을 수행한다. JVM은 스택기반의 가상머신이다. 다른 ARM아키텍쳐와 같은 하드웨어는 레지스터 기반으로 동작한다.      
    
    >cf)가상머신(VM)이라면 CPU에 의해 처리되는 동작을 흉내낼 수 있어야 한다.            
          1) 소스코드를 VM이 실행 가능한 바이트 코드로 변환한다.       
          2) 명령어와 피연산자를 포함하는 데이터 구조를 가지고 있어야 한다.        
          3) 함수를 실행하기 위한 콜 스택        
          4) IP(Instruction Pointer)로 다음 실행할 곳을 지정한다.      
          5) 가상 CPU: Fetch&Decode&Instruct         
    --가상머신을 구현하는 방법: Stack기반 vs Register기반      
          -Stack기반: 피연산자 연산 후, 결과를 스택에 저장 ->Stack: LIFO (다음 피연산자의 메모리 위치를 기억할 필요 없음)          
          -Register기반: 피연산자가 CPU내부의 Register에 저장된다. -> 명령어가 피연산자의 레지스터 주소를 기억해야 한다.명령어 길이가 길지만 다양한 연산을 할 수 있기 때문에 더 빠르다. 또한 최적화가 가능하다.      
          
  >### (4)Java프로그램 실행 과정            
  1. 프로그램이 실행되면 JVM은 OS로부터 필요한 메모리를 할당받는다. JVM은 할당받은 메모리를 용도에 따라 여러 영역으로 나누어 관리한다.     
  2. 자바 컴파일러 (javac)가 자바 소스코드(.java)를 읽어 자바 바이트 코드(.class)로 변환시킨다.      
  3. Class Loader를 통해 class파일을 JVM으로 로딩한다.       
  4. 로딩된 class파일들은 Execution engine을 통해 해석된다.           
  5. 해석된 바이트 코드는 Runtime Data Area에 배치되어 실질적인 수행이 이루어지게 된다.         
  --> 이 때, JVM은 필요에 따라 Thread Synchronization과 GC같은 관리작업을 수행한다.    
  
  >### (5)JVM    
  
  <div>      
  <img width="600" src="https://user-images.githubusercontent.com/58412156/88820974-fa541680-d1fc-11ea-89c9-436eebc19907.png">      
  </div>         
  
>>class loader     
        : JVM내로 클래스 파일을 로드하고, 링크를 통해 배치하는 작업을 수행하는 모듈. .jar파일 내 저장된 클래스 들을 JVM위에 탑재하고, 사용하지 않는 클래스들은 메모리에서 삭제한다. 자바는 런타임에 참조하기 때문에, 클래스를 처음으로 참조할 때, 해당 클래스를 로드하고 링크한다. 그 역할을 class loader가 수행한다.    
  <div>      
  <img width="600" src="https://user-images.githubusercontent.com/58412156/88830203-96374f80-d208-11ea-84b9-7257e2c9b2a4.png">      
  </div>      
   
    >>> 클래스 로더는 여러 클래스 로더끼리 부모-자식관계를 이루며 계층적인 구조로 되어 있다.   
     * 부트스트랩 클래스 로더(Bootstrap Class Loader)   
     최상위 클래스로더로 유일하게 JAVA가 아니라 네이티브 코드로 구현이 되어있다.   
     JVM이 실행될 때 같이 메모리에 올라간다   
     Object 클래스를 비롯하여 JAVA API들을 로드한다.    
     * 익스텐션 클래스 로더(Extension Class Loader)    
    기본 JAVA API를 제외한 확장 클래스들을 로드한다. (다양한 보안 확장기능 로드)   
     * 시스템 클래스 로더(System Class Loader)    
    부트스트랩과 익스텐션 클래스로더가 JVM 자체의 구성요소들을 로드한다면, 시스템 클래스 로더는 어플리케이션의 클래스들을 로드한다.   
    사용자가 지정한 $CLASSPATH 내의 클래스들을 로드한다.   
     * 사용자 정의 클래스 로더(User-Defined Class Loader)    
    어플리케이션 사용자가 직접 코드상에서 생성하여 사용하는 클래스로더.   
    >>> 클래스 로더는 위임모델을 사용하기 때문에, 처음 바이트 코드를 넘겨받은 클래스 로더가 필요한 클래스를 로드할 때, 혹은 실행엔진에서 명령어 단위로 바이트 코드를 실행하다가 처음으로 참조하는 클래스에 대해 로드를 요청할 때, 로드를 요청받은 클래스 로더는 이전에 로드된 클래스인지 클래스 로더 캐스를 확인하고, 없으면 상위 클래스 로더를 하나씩 거슬러 올라간다. 올라가는 도중에 클래스를 발견하더라도 부트스트랩 클래스 로더까지 학인을 해서 상위 클래스 노드에 있는 클래스를 로드한다. 최상위 클래스 로더에 해당 클래스가 없으면 파일 시스템에서 해당 클래스를 찾게 된다.
    >>> 클래스 로더가 클래스 로드를 요청받을때, 위임모델에 의해 상위 클래스 로더를 확인할 때, 하위 클래스 로더에 있는 클래스는 확인이 불가능 하다는 특성이 가시성 제한이다.
    >>> 클래스를 로드하는 것은 가능하지만, 언로드 하는 것은 불가능 하다
    >>> name space란 각 클래스 로더들이 로드된 클래스를 보관하는 공간이다. 위임모델로 확인 할 때, name space를 확인한다. 
>>Execution Engine     
        : 클래스를 실행시키는 역할을 하며, class loader가 JVM내의 런타임 데이터 영역에 바이트 코드를 배치시키고, 이것은 Execution Engine에 의해 실행된다. 자바 바이트 코드는 기계어보다 high language이므로, Execution엔진은 JVM내부에서 실행할 수 있는 형태로 변경한다.        
>>Interpreter    
        : Execution Engine은 자바 바이트코드를 명령어 단위로 읽어서 실행한다. 하지만 이 방식은 인터프리터 언어의 특징인 한 줄 씩 수행으로 인한 느린 속도를 그대로 갖고 있다.            
>>JIT(Just- In - Time)      
        : 인터프리터 방식의 단점을 보완하기 위해 JIT컴파일러가 도입된 것이다. 인터프리터 방식으로 실행하다가 적절한 시점에 바이트 코드 전체를 컴파일 하여 네이티브 코드로 변경하고, 이후에는 더이상 인터프리팅 하지 않고 네이티브 코드로 직접 실행하는 방식이다. 네이티브 코드는 캐시에 보관하기 때문에 한 번 컴파일 된 코드는 빠르게 다시 수행할 수 있다. , JIT를 사용하는 JVM은 내부적으로 해당 메서드가 얼마나 자주 수행되는지 체크하고, 일정 정도를 넘을 때에만 컴파일을 수행한다. >>Garbage collector (GC)             
       : stop-the-world란 GC를 실행하기 위해 JVM이 애플리케이션 실행을 멈추는 것이다. GC를 실행하는 thread이외의 thread는 모두 멈추게 되고, GC작업을 완료한 후에 다시 시작한다. 어떤 GC알고리즘을 사용하더라도 stop-the-world가 발생한다. 이 시간을 줄이는 것이 GC튜닝이다.      
         Java는 프로그램 코드에서 메모리를 명시적으로 지정하여 해제하지 않는다. 종종 해당 객체를 null이나 System.gc()메서드를 호출하여 해제하기도 하는데, System.gc()메서드는 시스템 성능에 큰 영향을 끼치므로, 사용하지 않는다. 따라서 Java에서는 개발자가 메모리를 해제하지 않아서, GC가 더이상 필요없는 쓰레기 객체를 찾아 지우는 작업을 한다.         
        GC는 두가지 가설(weak generational hypothesis)에 의해 만들어지는데, 대부분의 객체는 금방 접근 불가능 상태가 된다. / 오래된 객체에서 젊은 객체로의 참조는 아주 적게 존재한다.    
        이 가설의 장점을 살리기 위해 HotSpot VM은 새로 할당받으면 Young Generation영역에 위치한다. young 영역은 Eden과 Survivor영역으로 나뉜다. 대부분의 객체가 금방 접근 불가능 상태가 되기 때문에 금방 사라진다. 이때, Minor GC가 발생한다고 한다. 그리고 Young영역에서 살아남은 객체가 Old영역에 복사된다. 대부분 Young영역보다 크게 할당하며, 크기가 크기 때문에 GC는 적게 발생한다. 이 영역에서 객체가 사라질 때, Major GC가 발생한다고 말한다. 객체나 억류된 문자열 정보가 Permanent Generation에 저장된다. 이는 영원히 남아있는 곳은 아니다.        
         Old영역에 있는 객체가 Young 영역의 객체를 참조할 경우, Old역역에 512바이트의 카드 테이블이 존재하여, 참조할 때 마다 정보가 card table에 저장되고, Young역역에 GC를 실행할 때, Old영역의 참조 정보를 모두 확인할 필요 없이, 이 card table만 뒤져서 GC대상인지 식별한다. 카드테이블은 write barrier를 사용하여 오버헤드는 발생하지만 Minor GC를 빠르게 하도록 한다.     
         
 <ul> GC관련 링크: https://d2.naver.com/helloworld/1329 </ul>
 
>>Rutime Data Area        
    : 프로그램을 수행하기 위해 OS에서 할당받은 메모리 공간
    <div>      
  <img width="600" src="https://user-images.githubusercontent.com/58412156/88827881-76525c80-d205-11ea-94a7-73e386d97d66.png">      
  </div>      
  
    >>> PC register    
    : 쓰레드가 시작될 때 생성되며, 해당 쓰레드가 어떤 부분을 명령으로 실행해야 할지에 대해 기록하는 부분으로, 현재 수행중은 JVM명령의 주소를 저장한다.   
    >>> JVM 스택 영역   
    : 프로그램 실행과정에서 임시로 할당되었다가 메소드를 빠져나가면 바로 소멸되는 특성의 데이터를 저장하기 위한 영역.   
    >>> Native method stack   
    : 실제 실행할 수 있는 기계어로 작성된 프로그램을 실행시키는 영역. Java Native Interface를 통해 바이트코드로 전환하여 저장한다. 일반 프로그램처럼 커널이 스택을 잡아 독자적으로 프로그램을 실행시키는 영역으로, 이 부분을 통해 C code를 실행시켜서 Kernel에 접근할 수 있다.     
    >>> Method Area(class area, static area)    
    :  클래스 정보를 처음 메모리 공간에 올릴 때, 초기화되는 대상을 저장하기 위한 메모리 공간. 자바 프로그램은 main메소드 호출부터 계속된메소드의 호출로 흐름을 이어나가기 때문에, 올라가게 되는 메소드의 바이트 코드는 프로그램의 흐름을 구성하는 바이트 코드이다. 이 공간에 Runtime Constant Pool이라는 별도의 관리영역이 존재해서 상수 자료형을 저장하여 참조하고 중복을 막는 역할을 한다.    
     >>>> 올라가는 정보의 종류    
      1) field information: 멤버 변수 정보     
      2) Method Information: 메소드 정보    
      3) Type Information: class/interface인지, //// Type속성, 전체이름, superclass이름    
     --> method area는 클래스 데이터를 위한 공간이라면, heap영역은 객체를 위한 공간이다.    
    >>> Heap 영역    
    : 객체를 저장하는 가상 메모리 공간. 생성된 객체와 배여를 저장한다. 물론 class area에 올라온 클래스만 객체로 생성할 수 있다. 아까 GC에서 말한 객체 저장 공간(new, old, permenant)이 이 heap 영역이다. // 인스턴스는 소멸 방법과 소멸 시점이 지역변수와 다르기 때문에 힙이라는 별도의 영역에 할당된다.
    
======================================================================================================
## 2) 안드로이드
>### (1) 안드로이드 구조
>> 안드로이드에서 사용하는 언어는 JAVA이지만 SUN의 자바와 API와 VM이 다르다.  
    Dalvik이라는 회사의 버추얼 머신이 있었는데 구글에서 회사를 사들였다. 이 때문에 안드로이드는 SUN사의 라이센스로부터 자유롭다고 한다.
    
    <div>      
  <img width="600" src="https://user-images.githubusercontent.com/58412156/88832311-984edd80-d20b-11ea-9558-1b8ecb20fc21.png">      
  </div>     
  
>>  안드로이드 플랫폼은 크게 네 부분으로 나뉜다. 커널부분, 하드웨어추상레이어, 라이브러리, 응용프로그램 프레임워크. 라이브러리들은 C/C++로 구현이 되어 있다. 기존의 여러 프로젝트 들을 통합하였기 때문에 C로 구현된 것들이 대부분이고 C++도 있다. 응용프로그램 프레임워크는 자바로 구현되어 있다. 프레임워크와 라이브러리 사이에는 자바와 C 사이의 서로다른 호출 규약등을 맵핑하는 JNI라는 마셜러가 존재한다. 하드웨어 드라이버를 C로 만들면 JNI를 구현해야 한다. 이를 위한 구글 가이드가 있고 샘플도 공개되어 있다. 그리고 SDK를 생성하여 응용프로그램 개발자에게 전달하면 된다. 하드웨어 부분은 구글에서 표준으로 정해두었기 때문에 따로 만질 필요가 없다. 추상레이어도 스펙이 다 되어있어 응용프로그램을 개발할 때는 API로 보이게 된다.    
>> Android Kernel   
    * 안드로이드에서는 기존 리눅스의 라이브러리로 만든 것들은 동작하지 않는다고 보면 된다. 같은 이름의 라이브러리라 할지라도 안드로이드의 라이브러리들은 스마트폰에 탑재하는 것을 기준으로 불필요한 코드들을 제거하고 최적화를 해두었기 때문이다. POSIX Thread 관련 라이브러리를 예로 들면 create, join 등의 필수 함수를 제외한 나머지함수는 모두 제거되어있다.      
    * 리눅스에서는 각 프로세스마다 우선순위를 주고 메모리가 부족하면 우선순위가 낮은 것을 없앤다. 안드로이드는 프로세스마다 우선순위를 주지 않고 그룹마다 우선순위를 준다. 그 이유는 바인더 때문이다.  메모리 부족 시 우선순위가 낮은 그룹을 제거한다. 안드로이드에는 프로그램 종료 기능이 없다. 화면은 내릴 수 있지만 알아서 프로그램이 제거되기 때문이다. 자바로 응용프로그램을 만들기 때문에 가비지컬렉터가 있다. 종료버튼이 있다 하더라도 UI가 없어질 뿐 그 자체가 바로 종료되는 것은 아니다.   
    * 바인드를 호출하면 응용프로그램과 디바이스쪽에 바인드서비스가 붙어 서로 통신하게 된다. 바인드서비스는 커널이 아니다. 서로다른 서비스간, 응용프로그램간 데이터를 주고받을 때 동작하게 된다. 여기서의 단점은, 기존의 방식은 하나의 매개체가 있고 공유해서 썼지만 바인드는 각각의 서비스마다 바인더가 있어야 하기 때문에 메모리 낭비가 되는 측면이 있다. 그럼에도 불구하고 쓰는 이유는 바인더는 각각 별개로 동작하기 때문에 주고 받는 통신을 가로챔 당할 가능성이 더 낮아지므로 보안성이 더 오르기 때문이다.    
    * Low Memory Killer: 리소스가 부족할 때 자동으로 실행된다. 안드로이드는 그룹 당 우선순위를 주어 해당되는 그룹을 한번에 해제한다.  프로세스가 실행되면 프로세스테이블에 등록되어 관리가 된다. 메모리 부족현상이 생기면 shirink 함수가 실행되어 링크드리스트로 되어있는 프로세스컨트롤 블록들을 끝까지 탐색한다. 제거되어야 할 프로세스가 있으면 SIGKILL을 전송한다.    

>> Librarys 
    * 기존의 라이브러리를 그대로 사용하지 않고 EABI로 빌드된 라이브러리이다. 기존의 리눅스는 PC가 모태이기 때문에, 스마트 디바이스환경을 위해 만들어진 것이 아니기 때문에 arm또는 스마트디바이스에 최적화 되어 있지 않다. 바인더가 있고 자바의 JNI를 통해 C코드와 연결되기 때문에 필수적으로 사용되는 C라이브러리 사이즈를 줄이고 효율을 더 좋게 하였다.    
    * 모든 Native 코드는 bionic과 함께 컴파일 되어야 한다. / 웹킷은 오픈소스 브라우저 기반이다. 애플의 사파리, 노키아의 심비안에 이미 적용되어 성능은 검증되어 있다. 브라우저 속도가 아주 빠른것이 특징이다. HTML 표준을 따르고 Active X는 지원하지 않는다. / 미디어프레임워크는 PocketVideo OpenCORE 플랫폼 기반이다. 동영상 디코딩을 하며 표준 Video, Audio, Still-frame 포맷을 지원한다. 이를 이용해 상용제품을 양산할 경우 코덱 라이센스에 대한 비용이 발생할 수 있다. / SQLite 는 기본 데이터 베이스이다. Mysql과 거의 유사하다. 위치기반 서비스등을 할 때 유용하게 쓰일 수 있다. / Surface Manager는 모든 응용프로그램의 surface rendering을 프레임버퍼로 전달한다. 프레임버퍼는 LCD와 CPU속도에 차이가 있기 때문에  DRAM 또는 SRAM에 똑같은 구조를 만들어 두고 메모리 블록 전체를 복사해서 한번에 LCD에 출력한다. 이 때 그 메모리 공간을 프레임버퍼라고 한다. / Audio Manager는 오디오 처리를 한다. 오디로 출력 라우팅 기능이 구현되어 있다. 이전에는 OSS를 사용했는데 안드로이드에서 제대로 동작하지 않기 때문에 ALSA를 써야한다. 기본적으로 ALSA는 디폴트 볼륨이 0 으로 설정되어 있기 때문에 테스트를 하기 위해서는 init 부분에서 볼륨설정을 먼저 해줘야 한다.   
    
>> Andriod Runtime    
    
        <div>      
  <img width="600" src="https://user-images.githubusercontent.com/58412156/88834118-51aeb280-d20e-11ea-87de-1ac838fd7335.png">      
  </div>     
  
    * SUN의 자바는 명령들이 전부 8비트 길이를 가지지만 안드로이드는 4바이트이다. 기존의 SUN은 명령어가 스택에 들어가기 때문에 PUSH,POP명령어를 쓰고 Dalvik은 뱅크드레지스터를 이용한 복사명령을 이용하고 레지스터에서 바로 실행시키기 때문에 속도가 더 빠르다. 4바이트가 레지스터에 전부 들어가기 때문에 낮은사양에서도 느려지지 않는 효과도 있다. 프로그램동작은 자바코드이고 드라이버들은 대부분 C/C++이지만 그 사이에 JNI가 있기때문에 동작이 가능하다. JNI는 자바코드에서 C나 C++  라이브러리를 호출할 수 있도록 만들어진 규약이다. 안드로이드에서 응용프로그램은 C/C++로도 만들 수 있다. 대신 UI를 가지기는 힘들다. 백그라운드 서비스를 제작할 경우 굳이 자바로 할 필요는 없다.     
  
>> Hardware Abrstraction Layer (HAL)
  * 예전에는 하드웨어 드라이버를 하드웨어 제작자가 만들었지만 요즘은 추상계층을 두어 상위 드라이버나 하위 네이티브 드라이버를 서로 독립적으로 개발할 수 있고 응용프로그램도 독립적으로 동작할 수 있다. 이는 일관된 함수 이름과 형식이 있기때문에 가능하다. 개발자가 구현하기 쉽게 표준화된 API들이 존재하며 모든 제조사가 자신의 컴포넌트를 안드로이드 플랫폼에 넣을 수 있도록 구성되었다. HAL은 라이센스문제를 피하고 안정성을 위해 유저스페이스에 존재한다.   

>> Application Framework
  * 액티비티 매니저는 응용프로그램의 생명주기를 담당한다. 패키지 매니저는 시스템에서 동작중인 응용프로그램들의 정보를 담당한다. 윈도우 매니저는 모든 응용프로그램과 관련된 화면을 담당한다. 뷰 시스템은 표준 위젯을 담당한다. 처음 바탕화면이 위젯이다. 윈도우는 dll 파일이 많지만 안드로이드는 하나의 패키지 파일로 되어있어 프로그램 배포가 쉽다.
  
>### (2) 안드로이드 동작
>> Boot
<div>      
  <img width="600" src="https://user-images.githubusercontent.com/58412156/88835168-dbab4b00-d20f-11ea-85ca-666a46e2a16f.png">      
  </div>   
  
  * 리눅스는 기본적으로 init이 가장먼저 실행된다. init.rc 라는 이름의 파일에는 init이 해야할 작업들이 기록되어 있다. 파일시스템 마운팅, 폴더 권한설정, 캐시폴더 삭제, 시작프로그램 동작 등이 기록되어 있다. 우선 데몬을 올린다. 데몬은 init에 의해 리눅스와 같이 시작되었다가 리눅스가 종료될 때 없어지는 프로그램으로서 데몬을 작성하는 규격에 따라 만들어져야 한다. Zygote가 Dalvik을 초기화 한다. C 밑에 있는 기본라이브러리들은 런타임을 통해 실행되고 상위 서비스들은 Dalvik을 통해 실행된다. 이러한 과정들을 위한 설정은 해당하는 config 파일을 수정하면 된다. 어떤 동작들을 바꾸고 싶으면 기본적으로 init.rc를 바꾸면 되고 Zygote를 바꾸고 싶으면 그 설정파일을 바꾸면 된다. 그리고 시스템서버, 서페이스매니저, 오디오매니저들이 올라간다. 그 다음에는 시스템 서비스들이 활성화 된다. 이들은 서비스이므로 서비스매니저에 등록된다.
  
>>Zygote가 실행되면 시스템 서비스가 활성화 된다. 응용프로그램에서는 android.process.* 을 가지고 접근할 수있다. Zygote와 시스템서버간에는 IPC 소켓으로( 127.0.0.x ) 통신을 한다.
<div>      
  <img width="600" src="https://user-images.githubusercontent.com/58412156/88835504-51afb200-d210-11ea-8cff-a9adcf211d61.png">      
  </div>   
  
  *

